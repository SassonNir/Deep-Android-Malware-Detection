function buildNetwork(posNegRatio)

	local nIndex = 256
	local nOutputSamples = opt.nConvFilters    -- number of conv-filters
	local kernelStride = 1      -- stride of kernel
	local nClasses = 2
	local nHidden = opt.nHiddenNodes

	local model = nn.Sequential()

	-- project from one-hot to low-dim embedding space
	if opt.constrainEmbeddingNorm then	
		model:add(nn.LookupTable(nIndex,opt.nEmbeddingDims,0,1,2))
	else
		model:add(nn.LookupTable(nIndex,opt.nEmbeddingDims))
	end

	-- we can add this here to prevent the network from updating the projection layer
	-- maybe the projection does not matter much?
	-- model:add(nn.GradBlocker())

	-- 1st conv layer
	--model:add(nn.Reshape(1,opt.programLen,opt.nEmbeddingDims,true))
	model:add(nn.Reshape(1,-1,opt.nEmbeddingDims,true))

	if opt.useSpatialDropout then
		-- should be batchx1xproglenxembeddingdim
		model:add(nn.Reshape(opt.programLen,opt.nEmbeddingDims,1,true))
		model:add(nn.SpatialDropout(opt.dropoutFrac))
		model:add(nn.Reshape(1,opt.programLen,opt.nEmbeddingDims,true))
	end

	--model:add(nn.SpatialZeroPadding(0,0,opt.kernelLength,opt.kernelLength))

	if opt.useDropoutAfterEmbedding then
		model:add(nn.Dropout(opt.dropoutFrac))
	end

	model:add(nn.SpatialConvolutionMM(1,opt.nConvFilters,opt.nEmbeddingDims,opt.kernelLength,kernelStride))
	model:add(nn.ReLU())

	-- if opt.nConvLayers > 1 then
	-- 	for layernum = 1,(opt.nConvLayers-1) do

	-- 		model:add(nn.Reshape(opt.nConvFilters,-1,true))	
	-- 		model:add(nn.Transpose({2,3}))
	-- 		--model:add(nn.TemporalMaxPooling(opt.kernelLength/2,opt.kernelLength/2))
	-- 		model:add(nn.TemporalMaxPooling(2,2))
	-- 		model:add(nn.Reshape(1,-1,opt.nConvFilters,true))

	-- 		model:add(nn.SpatialZeroPadding(0,0,opt.kernelLength,opt.kernelLength))
	-- 		model:add(nn.SpatialConvolutionMM(1,opt.nConvFilters,opt.nConvFilters,opt.kernelLength,kernelStride))

	-- 		model:add(nn.ReLU())			

	-- 	end
	-- end


	model:add(nn.Reshape(opt.nConvFilters,-1,true))	

	if opt.useDropoutAfterConv then
		model:add(nn.Dropout(opt.dropoutFrac))
	end

	model:add(nn.Max(3)) -- produces a vector of fixed size
	
	if opt.useHiddenLayer then
		model:add(nn.Linear(nOutputSamples,nHidden))
		model:add(nn.ReLU())
		model:add(nn.Linear(nHidden,nClasses))
	else
		model:add(nn.Linear(nOutputSamples,nClasses))
	end
	model:add(nn.LogSoftMax())
	
	local criterion = 0
	if opt.weightClasses then

		local weights = torch.zeros(nClasses)
		if posNegRatio < 0.5 then
			weights[1] = 1 - posNegRatio
			weights[2] = posNegRatio
		else
			weights[2] = 1 - posNegRatio
			weights[1] = posNegRatio
		end
		criterion = nn.ClassNLLCriterion(weights)
	else
		criterion = nn.ClassNLLCriterion()
	end

	if opt.useCUDA then
		model:cuda()
		criterion:cuda()
	end

	print(model)

	return model,criterion
end