import os
from bidict import bidict
from tqdm import tqdm
import subprocess
import random
import shutil
import re
import warnings
import abc
import dataclasses
import typing
import operator
import tempfile
import threading
import queue
import functools
import string
import logging

DEBUG = True


APKTOOL_PATH = os.path.join('/', 'usr', 'local', 'bin', 'apktool')
ZIPALIGN_PATH = os.path.join('/', 'usr', 'bin', 'zipalign')
UBER_APK_SIGNER_PATH = os.path.join(
    '/', 'usr', 'local', 'bin', 'uber-apk-signer.jar')

MODELS_PATH = os.path.join('.', 'models')
METADATAS_PATH = os.path.join('.', 'metadatas')
BENIGN_APKS = os.path.join('.', 'benign_apks')
MALWARE_APKS = os.path.join('.', 'malware_apks')

BEFORE_APKS_PATH = os.path.join('.', 'data', 'Before-Apps')
AFTER_APKS_PATH = os.path.join('.', 'data', 'After-Apps')
BEFORE_OPSEQS_PATH = os.path.join('.', 'data', 'Before-Opseqs')
AFTER_OPSEQS_PATH = os.path.join('.', 'data', 'After-Opseqs')

BENIGN_LABEL = 'Benign'
MALWARE_LABEL = 'Malware'

# opseq file name format: <app_name>.apk.opseq
OPSEQS_FILENAME_FORMAT = re.compile(r'^(.+)\.apk\.opseq$')
# malware file name format: app<app_number>.apk
MALWARE_FILENAME_FORMAT = re.compile(r'^app(\d+)\.apk$')
# benign file name format: <app_name>.apk
BENIGN_FILENAME_FORMAT = re.compile(r'^(.+)\.apk$')

READ_TEST_METADATA_SCRIPT = os.path.join('.', 'readMetadata.lua')
RUN_MODEL_SCRIPT = os.path.join('.', 'runModel.lua')

LOCALS_PATTERN = re.compile(r"\s+\.locals\s(?P<local_amount>\d+)")


DALVIK_OPCODES = bidict()
with open('DalvikOpcodes.txt', 'r') as f:
    for line in f:
        line = line.strip()
        op, val = line.split('\t')
        DALVIK_OPCODES[op] = val


@dataclasses.dataclass
class App:
    name: str
    label: str
    path: typing.Optional[str] = None # directory path of the app

    @property
    def is_malware(self) -> bool:
        return self.label == MALWARE_LABEL

    @property
    def is_benign(self) -> bool:
        return self.label == BENIGN_LABEL
    
    @property
    def opseq_name(self) -> str:
        return f'{self.name}.apk.opseq'
    
    @property
    def apk_name(self) -> str:
        return f'{self.name}.apk'
    
    @property
    def opseq_path(self) -> str:
        return os.path.join(self.path, self.opseq_name)
    
    @property
    def apk_path(self) -> str:
        return os.path.join(self.path, self.apk_name)
    

    def __str__(self) -> str:
        return f'{self.name} ({self.label})'

    def __repr__(self) -> str:
        return f'{self.name} ({self.label})'

def get_test_metadata(metadata_path: str) -> list[App]:
    # if DEBUG:
    #     print(f'[+] Getting test metadata from {metadata_path}')
    logging.info(f'Getting test metadata from {metadata_path}')
    metadata = subprocess.run(['th', READ_TEST_METADATA_SCRIPT,
                              '-metadataPath', metadata_path], capture_output=True, text=True)
    lines = metadata.stdout.splitlines()
    # format of first line: 1=<label_name_1>\t2=<label_name_2>\t...
    label_names = {k: v for k, v in [label.split(
        '=') for label in lines[0].strip().split('\t')]}
    # format of remaining lines: <app_name>.apk.opseqs\t<app_label>
    # data = {}
    data = []
    # return {OPSEQS_FILENAME_FORMAT.match(app_name).group(1): label_names[app_label] for app_name, app_label in [line.split('\t') for line in lines[1:]]}
    for line in tqdm(lines[1:], desc='Parsing the metadata', disable=not DEBUG, leave=None):
        app_name, app_label = line.strip().split('\t')
        # data[OPSEQS_FILENAME_FORMAT.match(
        #     app_name).group(1)] = label_names[app_label]
        data.append(App(OPSEQS_FILENAME_FORMAT.match(
            app_name).group(1), label_names[app_label]))
    return data

def copy_apks(apks: list[App], malware_source_path: str, benign_source_path: str, dest_path: str) -> list[App]:
    transfered_files = []
    # remove all files in dest_path
    for file in os.listdir(dest_path):
        os.remove(os.path.join(dest_path, file))
    for app in tqdm(apks, desc='Copying apks', disable=not DEBUG, leave=None):
        # print(app_name)
        dest = os.path.join(dest_path, app.apk_name)

        if app.is_malware:
            source = malware_source_path
        elif app.is_benign:
            source = benign_source_path
        else:
            # raise ValueError(f'Invalid app label: {app.label}')
            # if DEBUG:
            #     print(f'[!] Invalid app label: {app.label}')
            logging.warning(f'Invalid app label: {app.label}')
            continue
        sour = os.path.join(source, app.apk_name)
        if not os.path.exists(sour):
            # warnings.warn(f'File {sour} does not exist')
            logging.warning(f'File {sour} does not exist')
            continue

        shutil.copy(sour, dest)
        transfered_files.append(App(app.name, app.label, dest_path))
    return transfered_files


class SavableInterface(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook__(cls, subclass):
        return ((hasattr(subclass, 'save') and callable(subclass.save)) or NotImplemented)

    @abc.abstractmethod
    def save(self, path: str) -> None:
        """Save the object to the given path"""
        raise NotImplementedError


@dataclasses.dataclass
class Line:
    value: str
    opcode: typing.Optional[str] = None

    @property
    def has_opcode(self) -> bool:
        return self.opcode is not None

    @property
    def indentation(self) -> int:
        return len(self.value) - len(self.value.lstrip())


class Method:
    def __init__(self, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.opcode_map = opcode_map
        self.lines: list[Line] = []
        self.has_opcode = False

    def add_line(self, line: str, position: int = None) -> None:
        if position is None:
            position = len(self.lines)
        line = line.rstrip()
        if not line:
            return
        sline = line.lstrip()
        opcode = None
        if sline and not sline.startswith('.') and not sline.startswith('#'):
            parts = sline.split(" ", maxsplit=1)
            if (len(parts) >= 1) and (parts[0] in self.opcode_map):
                opcode = self.opcode_map[parts[0]]
                self.has_opcode = True
        self.lines.insert(position, Line(line, opcode))

    def remove_line(self, position: int) -> None:
        self.lines.pop(position)

    def get_lines(self) -> typing.Generator[tuple[int, Line], None, None]:
        return (l for l in enumerate(self.lines) if l[1].has_opcode)

    def get_opcode_seq(self) -> str:
        return "".join(map(operator.attrgetter('opcode'), (l[1] for l in self.get_lines())))

    def __str__(self) -> str:
        return '\n'.join(map(operator.attrgetter('value'), self.lines))


class SmaliFile(SavableInterface):
    def __init__(self, smali_path: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.smali_path = smali_path
        self.opcode_map = opcode_map
        self.lines: list[typing.Union[Method, str]] = []
        self.current_method: typing.Optional[Method] = None
        self.has_opcode = False

    @classmethod
    def from_file(cls, smali_path: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        smali = cls(smali_path, opcode_map)
        with open(smali_path, mode="r", encoding="utf-8") as smali_file:
            t = tqdm(total=os.path.getsize(smali_path), unit="B", postfix={
                     "dir": smali_path}, disable=not DEBUG, leave=None)
            for line in smali_file:
                t.update(len(line))
                smali.add_line(line)
            if smali.current_method:
                logging.warning(f"File {smali.smali_path} contains an closed method")
                raise SyntaxError(
                    f"File {smali.smali_path} contains an closed method")
            t.close()
        return smali

    def add_line(self, line: str) -> None:
        sline = line.strip()
        if not sline:
            return
        if sline.startswith(".method"):
            if self.current_method:
                logging.warning(f"File {self.smali_path} contains an closed method")
                raise SyntaxError(
                    f"File {self.smali_path} contains an closed method")
            self.current_method = Method(self.opcode_map)
            self.current_method.add_line(line)
        elif sline.startswith(".end method"):
            if not self.current_method:
                logging.warning(f"File {self.smali_path} contains a hanging .end method")
                raise SyntaxError(
                    f"File {self.smali_path} contains a hanging .end method")
            self.current_method.add_line(line)
            self.lines.append(self.current_method)
            # If any of the methods have an opcode then the file has an opcode
            self.has_opcode |= self.current_method.has_opcode
            self.current_method = None
        elif self.current_method:  # inside the method
            self.current_method.add_line(line)
        else:  # self.current_method is None
            self.lines.append(line.rstrip())

    def get_methods(self) -> typing.Generator[tuple[int, Method], None, None]:
        return (l for l in enumerate(self.lines) if isinstance(l[1], Method) and l[1].has_opcode)

    def get_opcode_seq(self) -> str:
        if self.current_method:
            logging.warning(f"File {self.smali_path} contains an closed method")
            raise SyntaxError(
                f"File {self.smali_path} contains an closed method")
        return "\n".join(map(operator.methodcaller('get_opcode_seq'), (m[1] for m in self.get_methods()))) if self.has_opcode else ""

    def __str__(self) -> str:
        return '\n'.join(str(l) for l in self.lines)

    def save(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, mode="w", encoding="utf-8", newline='\n') as smali_file:
            smali_file.write(str(self))


class SmaliDir(SavableInterface):
    def __init__(self, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.decoded_dir = decoded_dir
        self.opcode_map = opcode_map
        self.smali_files: list[SmaliFile] = []

    @classmethod
    def from_dir(cls, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        smali = cls(decoded_dir, opcode_map)
        smali_dir = os.path.join(smali.decoded_dir, "smali")
        total = 1
        if DEBUG:
            total = sum(len(files) for _, _, files in os.walk(smali_dir))
        t = tqdm(total=total, unit="files", disable=not DEBUG, leave=None)
        for root, dirs, files in os.walk(smali_dir):
            dirs.sort()
            t.set_postfix(dir=root[len(smali.decoded_dir):])
            t.update(0)
            for file in sorted(f for f in files if f.endswith(".smali")):
                smali_file = os.path.join(root, file)
                smali.add_file(smali_file)
                t.update()
        t.close()
        return smali

    def add_file(self, file_path: str) -> None:
        self.smali_files.append(
            SmaliFile.from_file(file_path, self.opcode_map))

    def get_files(self) -> typing.Generator[SmaliFile, None, None]:
        return (f for f in self.smali_files if f.has_opcode)

    def get_opcode_seq(self) -> str:
        # return "\n".join(f.get_opcode_seq() for f in self.smali_files if f.has_opcode)
        return "\n".join(map(operator.methodcaller('get_opcode_seq'), self.get_files()))
    
    def apply_nop(self) -> None:
       # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        files_list = list(self.get_files())
        for smali_file in tqdm(files_list, unit="files", disable=not DEBUG, leave=None):
            methods_list = list(smali_file.get_methods())
            for i, method in tqdm(methods_list, unit="methods", disable=not DEBUG, leave=None):
                lines_list = list(method.get_lines())
                amount =  len(method.lines)
                offset = 0
                for j, line in tqdm(lines_list, unit="lines", disable=not DEBUG, leave=None):
                    method.add_line((' ' * line.indentation) + "nop", position=(j + offset + 1))
                    offset += len(method.lines) - amount
                    amount = len(method.lines)

    def apply_branch(self) -> None:
       # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            m = Method(self.opcode_map)
            for method in tqdm(smali_file.lines, unit="methods", disable=not DEBUG, leave=None):
                if isinstance(method, Method) and (" abstract " not in method.lines[0].value) and (" native " not in method.lines[0].value):
                    start_label = None
                    end_label = None
                    m.add_line(method.lines[0].value)
                    for line in tqdm(method.lines[1:-1], unit="lines", disable=not DEBUG, leave=None):
                        if LOCALS_PATTERN.match(line.value):
                            m.add_line(line.value)
                            match = LOCALS_PATTERN.match(line.value)
                            if match and int(match.group("local_amount")) >= 2:
                                v0, v1 = random.randint(1, 32), random.randint(1, 32)
                                start_label = "".join(random.choices(string.ascii_letters, k=16))
                                end_label = "".join(random.choices(string.ascii_letters, k=16))
                                tmp_label = "".join(random.choices(string.ascii_letters, k=16))
                                m.add_line(f"{' ' * line.indentation}const v0, {v0}")
                                m.add_line(f"{' ' * line.indentation}const v1, {v1}")
                                m.add_line(f"{' ' * line.indentation}add-int v0, v0, v1")
                                m.add_line(f"{' ' * line.indentation}rem-int v0, v0, v1")
                                m.add_line(f"{' ' * line.indentation}if-gtz v0, :{tmp_label}")
                                m.add_line(f"{' ' * line.indentation}goto/32 :{end_label}")
                                m.add_line(f"{' ' * line.indentation}:{tmp_label}")
                                m.add_line(f"{' ' * line.indentation}:{start_label}")
                        else:
                            m.add_line(line.value)
                    if start_label and end_label:
                        m.add_line(f"{' ' * method.lines[-2].indentation}:{end_label}")
                        m.add_line(f"{' ' * method.lines[-2].indentation}goto/32 :{start_label}")
                    m.add_line(method.lines[-1].value)
                    method.lines = m.lines
    
    def apply_goto(self) -> None:
            # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            m = Method(self.opcode_map)
            for method in tqdm(smali_file.lines, unit="methods", disable=not DEBUG, leave=None):
                if isinstance(method, Method) and (" abstract " not in method.lines[0].value) and (" native " not in method.lines[0].value):
                    m.add_line(method.lines[0].value)
                    for line in tqdm(method.lines[1:-1], unit="lines", disable=not DEBUG, leave=None):
                        if LOCALS_PATTERN.match(line.value):
                            m.add_line(line.value)
                            m.add_line(f"{' ' * line.indentation}goto/32 :after_last_instruction")
                            m.add_line(f"{' ' * line.indentation}:before_first_instruction")
                        else:
                            m.add_line(line.value)
                    m.add_line(f"{' ' * method.lines[-2].indentation}:after_last_instruction")
                    m.add_line(f"{' ' * method.lines[-2].indentation}goto/32 :before_first_instruction")
                    m.add_line(method.lines[-1].value)
                    method.lines = m.lines
    
    
    def apply_all(self) -> None:
        # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            m = Method(self.opcode_map)
            for method in tqdm(smali_file.lines, unit="methods", disable=not DEBUG, leave=None):
                if isinstance(method, Method) and (" abstract " not in method.lines[0].value) and (" native " not in method.lines[0].value):
                    start_label = None
                    end_label = None
                    m.add_line(method.lines[0].value)
                    for line in tqdm(method.lines[1:-1], unit="lines", disable=not DEBUG, leave=None):
                        if LOCALS_PATTERN.match(line.value):
                            m.add_line(line.value)
                            match = LOCALS_PATTERN.match(line.value)
                            if match:
                                m.add_line(f"{' ' * line.indentation}goto/32 :after_last_instruction")
                                m.add_line(f"{' ' * line.indentation}:before_first_instruction")
                                
                                if int(match.group("local_amount")) >= 2:
                                    v0, v1 = random.randint(1, 32), random.randint(1, 32)
                                    start_label = "".join(random.choices(string.ascii_letters, k=16))
                                    end_label = "".join(random.choices(string.ascii_letters, k=16))
                                    tmp_label = "".join(random.choices(string.ascii_letters, k=16))
                                    m.add_line(f"{' ' * line.indentation}const v0, {v0}")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}const v1, {v1}")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}add-int v0, v0, v1")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}rem-int v0, v0, v1")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}if-gtz v0, :{tmp_label}")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}goto/32 :{end_label}")
                                    m.add_line(f"{' ' * line.indentation}nop")
                                    m.add_line(f"{' ' * line.indentation}:{tmp_label}")
                                    m.add_line(f"{' ' * line.indentation}:{start_label}")
                        else:
                            m.add_line(line.value)
                    if start_label and end_label:
                        m.add_line(f"{' ' * method.lines[-2].indentation}:{end_label}")
                        m.add_line(f"{' ' * method.lines[-2].indentation}goto/32 :{start_label}")
                        m.add_line(f"{' ' * line.indentation}nop")
                    m.add_line(f"{' ' * method.lines[-2].indentation}:after_last_instruction")
                    m.add_line(f"{' ' * method.lines[-2].indentation}goto/32 :before_first_instruction")
                    m.add_line(f"{' ' * line.indentation}nop")
                    m.add_line(method.lines[-1].value)
                    if method.lines[-1].has_opcode:
                        m.add_line(f"{' ' * line.indentation}nop")
                    method.lines = m.lines
            
    def save(self, directory: str):
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            smali_dir = os.path.join(
                directory, smali_file.smali_path[len(self.decoded_dir + os.sep):])
            smali_file.save(smali_dir)


# def parse_apk(app: App, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES, show_steps: bool = False) -> SmaliDir:
#     if show_steps:
#         subprocess.run([APKTOOL_PATH, "d", "-f", app.apk_path, "-o",
#                         decoded_dir, "--frame-path", decoded_dir], check=True, input=b"\r\n")
#     else:
#         subprocess.run([APKTOOL_PATH, "d", "-f", app.apk_path, "-o",
#                         decoded_dir, "--frame-path", decoded_dir], check=True, input=b"\r\n", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
#     return SmaliDir.from_dir(decoded_dir, opcode_map)
def parse_apk(app: App, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES) -> SmaliDir:
    try:
        out = subprocess.run([APKTOOL_PATH, "d", "-f", app.apk_path, "-o", decoded_dir, "--frame-path", decoded_dir], check=True, capture_output=True, input=b"\r\n")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error while parsing apk: {e}")
        logging.error(f"Output: {e.output}")
        logging.error(f"Returncode: {e.returncode}")
        raise e
    logging.debug(f"Output: {out.stdout}")
    logging.debug(f"Returncode: {out.returncode}")
    return SmaliDir.from_dir(decoded_dir, opcode_map)

def write_opseq(smali: SmaliDir, opseq_path: str) -> None:
    with open(opseq_path, mode="w", encoding="utf-8", newline='\n') as opseq_file:
        opseq_file.write(smali.get_opcode_seq())

def write_smali_dir(smali_dir: SmaliDir, decoded_dir: str) -> None:
    smali_dir.save(decoded_dir)

def build_apk(decoded_dir: str, output_apk_path: str) -> None:
    # if show_steps:
    #     subprocess.run([APKTOOL_PATH, "b", "-f", decoded_dir, "-o", output_apk_path, "--frame-path", decoded_dir], check=True, input=b"\r\n")
    # else:
    #     subprocess.run([APKTOOL_PATH, "b", "-f", decoded_dir, "-o", output_apk_path, "--frame-path", decoded_dir], check=True, input=b"\r\n", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    try:
        out = subprocess.run([APKTOOL_PATH, "b", "-f", decoded_dir, "-o", output_apk_path, "--frame-path", decoded_dir], check=True, capture_output=True, input=b"\r\n")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error while building apk: {e}")
        logging.error(f"Output: {e.output}")
        logging.error(f"Erorr: {e.stderr}")
        logging.error(f"Returncode: {e.returncode}")
        raise e
    logging.debug(f"Output: {out.stdout}")
    logging.debug(f"Returncode: {out.returncode}")
    
def sign_apks(apks_path: str, show_steps: bool = False) -> None:
    # # https://github.com/patrickfav/uber-apk-signer
    # if show_steps:
    #     subprocess.run(["java", "-jar", UBER_APK_SIGNER_PATH, 
    #                     "-a", apks_path,
    #                     '--overwrite',
    #                     '--zipAlignPath', ZIPALIGN_PATH], check=True)   
    # else:
    #     subprocess.run(["java", "-jar", UBER_APK_SIGNER_PATH, 
    #                     "-a", apks_path,
    #                     '--overwrite',
    #                     '--zipAlignPath', ZIPALIGN_PATH], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    try:
        out = subprocess.run(["java", "-jar", UBER_APK_SIGNER_PATH, 
                            "-a", apks_path,
                            '--overwrite',
                            '--zipAlignPath', ZIPALIGN_PATH], check=True, capture_output=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"Error while signing apk: {e}")
        logging.error(f"Output: {e.output}")
        logging.error(f"Returncode: {e.returncode}")
        raise e
    logging.debug(f"Output: {out.stdout}")
    logging.debug(f"Returncode: {out.returncode}")


def run_model(model_path: str, data_dir: str, use_cuda: bool = False) -> list[App]:
    try:
        if use_cuda:
            predictions = subprocess.run(['th', RUN_MODEL_SCRIPT,
                                        '-dataDir', data_dir,
                                        '-modelPath', model_path,
                                        '-useCUDA'],
                                        capture_output=True, text=True)
        else:
            predictions = subprocess.run(['th', RUN_MODEL_SCRIPT,
                                        '-dataDir', data_dir,
                                        '-modelPath', model_path],
                                        capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        logging.error(f"Error while running model: {e}")
        logging.error(f"Output: {e.output}")
        logging.error(f"Returncode: {e.returncode}")
        raise e
    logging.debug(f"Args: {predictions.args}")
    logging.debug(f"Output: {predictions.stdout}")
    logging.debug(f"Returncode: {predictions.returncode}")
    lines = predictions.stdout.splitlines()
    label_names = {k: v for k, v in [label.split(
        '=') for label in lines[0].strip().split('\t')]}
    data = []
    for line in tqdm(lines[1:], desc='Parsing the predictions', disable=not DEBUG, leave=None):
        app_name, app_label = line.strip().split('\t')
        # data[OPSEQS_FILENAME_FORMAT.match(
        #     app_name).group(1)] = label_names[app_label]
        data.append(App(OPSEQS_FILENAME_FORMAT.match(
            app_name).group(1), label_names[app_label], data_dir))
    return data

def display_confusion_matrix(prediction: list[App], ground_truth: list[App], outputname: str) -> None:
    prediction = {app.name: (app.label == MALWARE_LABEL) for app in prediction}
    ground_truth = {app.name: (app.label == MALWARE_LABEL) for app in ground_truth if (app.name in prediction)}
    if len(prediction) != len(ground_truth):
        # warnings.warn(
        #     f'The number of unique predictions ({len(prediction)}) and the number of unique ground truths ({len(ground_truth)}) are different')
        logging.warning(
            f'The number of unique predictions ({len(prediction)}) and the number of unique ground truths ({len(ground_truth)}) are different')
        
    confusion_matrix = [[0, 0], [0, 0]]
    for app in prediction:
        if app in ground_truth:
            confusion_matrix[ground_truth[app]][prediction[app]] += 1
        else:
            # if DEBUG:
            #     warnings.warn(f'The app {app} is not in the ground truth')
            logging.warning(f'The app {app} is not in the ground truth')
    # print(f'Confusion matrix: {confusion_matrix}')
    # pretty print
    print('Confusion matrix:')
    print(' ' * 4, 'PREDICTED')
    print(' ' * 4, '0', '1')
    print(' ' * 4, '-' * 3)
    print(' ' * 4, confusion_matrix[0][0], confusion_matrix[0][1])
    print(' ' * 4, confusion_matrix[1][0], confusion_matrix[1][1])
    print(' ' * 4, '-' * 3)
    print(' ' * 4, '0', '1')
    print(' ' * 4, 'GROUND TRUTH')
    print(' ' * 4, '-' * 3)
    print(' ' * 4, 'BENIGN', 'MALWARE')
    print(' ' * 4, '-' * 3)
    print('True Positive (Malware detected):', confusion_matrix[1][1])
    print('False Negative (Malware not detected):', confusion_matrix[1][0])
    # print('True Negative (Benign detected):', confusion_matrix[0][0])
    # print('False Positive (Benign not detected):', confusion_matrix[0][1])
    print('Recall (Malware detected):', confusion_matrix[1][1] / (confusion_matrix[1][1] + confusion_matrix[1][0]))
    # output the above values to a file
    with open(os.path.join('.', outputname), 'w') as f:
        f.write('Confusion matrix:\n')
        f.write(' ' * 4 + 'PREDICTED\n')
        f.write(' ' * 4 + '0' + '1\n')
        f.write(' ' * 4 + '-' * 3 + '\n')
        f.write(' ' * 4 + str(confusion_matrix[0][0]) + str(confusion_matrix[0][1]) + '\n')
        f.write(' ' * 4 + str(confusion_matrix[1][0]) + str(confusion_matrix[1][1]) + '\n')
        f.write(' ' * 4 + '-' * 3 + '\n')
        f.write(' ' * 4 + '0' + '1\n')
        f.write(' ' * 4 + 'GROUND TRUTH\n')
        f.write(' ' * 4 + '-' * 3 + '\n')
        f.write(' ' * 4 + 'BENIGN' + 'MALWARE\n')
        f.write(' ' * 4 + '-' * 3 + '\n')
        f.write('True Positive (Malware detected): ' + str(confusion_matrix[1][1]) + '\n')
        f.write('False Negative (Malware not detected): ' + str(confusion_matrix[1][0]) + '\n')
        # f.write('True Negative (Benign detected): ' + str(confusion_matrix[0][0]) + '\n')
        # f.write('False Positive (Benign not detected): ' + str(confusion_matrix[0][1]) + '\n')
        f.write('Recall (Malware detected): ' + str(confusion_matrix[1][1] / (confusion_matrix[1][1] + confusion_matrix[1][0])) + '\n')
    

NUM_THREADS = 5
q = queue.Queue()
last_output: list[tuple[App, SmaliDir]] = [None]
succeed: list[App] = []
prog = tqdm(total=1, disable=not DEBUG, leave=None)

def copy_apk(app: App, malware_source_path: str, benign_source_path: str, dest_path: str) -> typing.Optional[App]:
    # remove all files in dest_path
    dest = os.path.join(dest_path, app.apk_name)
    if os.path.exists(dest):
        os.remove(dest)  
    if app.is_malware:
        source = malware_source_path
    elif app.is_benign:
        source = benign_source_path
    else:
        # raise ValueError(f'Invalid app label: {app.label}')
        # if DEBUG:
        #     warnings.warn(f'Invalid app label: {app.label}')
        logging.warning(f'Invalid app label: {app.label}')
        return None
    sour = os.path.join(source, app.apk_name)
    if not os.path.exists(sour):
        # if DEBUG:
        #     warnings.warn(f'File {sour} does not exist')
        logging.warning(f'File {sour} does not exist')
        return None

    shutil.copy(sour, dest)
    return App(app.name, app.label, dest_path)


def process_app():
    global q
    global prog
    while True:
        app = q.get()
        try:
            apk = copy_apk(app, MALWARE_APKS, BENIGN_APKS, BEFORE_APKS_PATH)
            if apk:
                with tempfile.TemporaryDirectory() as decoded_dir:
                    smali_dir = parse_apk(apk, decoded_dir)
                    write_opseq(smali_dir, os.path.join(BEFORE_OPSEQS_PATH, app.opseq_name))
                    # attack here <<<<
                    # smali_dir.apply_goto()
                    # smali_dir.apply_branch()
                    smali_dir.apply_nop()
                    # smali_dir.apply_all()
                    # attack(smali_dir)
                    write_smali_dir(smali_dir, decoded_dir)
                    # for the last apk we save the smali_dir
                    last_output[0] = (app, smali_dir)
                    build_apk(decoded_dir, os.path.join(AFTER_APKS_PATH, app.apk_name))
                    write_opseq(smali_dir, os.path.join(AFTER_OPSEQS_PATH, app.opseq_name))
                    succeed.append(app)
        except Exception as e:
            # if DEBUG:
            #     warnings.warn(f'Error while processing {app.name}: {e}')
            logging.warning(f'Error while processing {app.name}: {e}')
            # delete the apk if it exists
            if os.path.exists(os.path.join(BEFORE_APKS_PATH, app.apk_name)):
                os.remove(os.path.join(BEFORE_APKS_PATH, app.apk_name))
            if os.path.exists(os.path.join(AFTER_APKS_PATH, app.apk_name)):
                os.remove(os.path.join(AFTER_APKS_PATH, app.apk_name))
            if os.path.exists(os.path.join(BEFORE_OPSEQS_PATH, app.opseq_name)):
                os.remove(os.path.join(BEFORE_OPSEQS_PATH, app.opseq_name))
            if os.path.exists(os.path.join(AFTER_OPSEQS_PATH, app.opseq_name)):
                os.remove(os.path.join(AFTER_OPSEQS_PATH, app.opseq_name))
        prog.update()
        q.task_done()


run = '1' # <<<< CHANGE THIS
logging.basicConfig(filename=f'./logs/log{run}.log', level=logging.DEBUG)

metadata = get_test_metadata(os.path.join(
    METADATAS_PATH, f'metadata{run}.th7'))
metadata = [m for m in metadata if m.label == MALWARE_LABEL][:10]

prog.total = len(metadata)
prog.desc = 'Processing apps'
# prog.disable = not DEBUG
prog.refresh()
threads = []
for meta in metadata:
    q.put(meta)

for i in range(NUM_THREADS):
    t = threading.Thread(target=process_app)
    t.daemon = True
    t.start()
    threads.append(t)
q.join()
before_predictions = run_model(os.path.join(MODELS_PATH, f'model{run}.th7'), BEFORE_OPSEQS_PATH)
display_confusion_matrix(before_predictions, metadata, outputname=f'confusion_matrix{run}_before.txt')
after_predictions = run_model(os.path.join(MODELS_PATH, f'model{run}.th7'), AFTER_OPSEQS_PATH)
display_confusion_matrix(after_predictions, metadata, outputname=f'confusion_matrix{run}_after.txt')
sign_apks(AFTER_APKS_PATH)
last_output[0][1].save(os.path.join('.', f'last_output{last_output[0][0].name}'))

# APP_NAME = 'app2933'
# apk = App(APP_NAME, MALWARE_LABEL, MALWARE_APKS)
# decoded_dir = os.path.join(BEFORE_APKS_PATH, f'{APP_NAME}_decoded')
# smali_dir = parse_apk(apk, decoded_dir)
# write_opseq(smali_dir, os.path.join(BEFORE_OPSEQS_PATH, apk.opseq_name))
# # attack here
# # smali_dir.apply_nop()
# # smali_dir.apply_goto()
# smali_dir.apply_branch()
# # attack(smali_dir)
# write_smali_dir(smali_dir, decoded_dir)
# build_apk(decoded_dir, os.path.join(AFTER_APKS_PATH, apk.apk_name))
