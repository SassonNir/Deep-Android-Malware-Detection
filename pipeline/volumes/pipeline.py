import os
from bidict import bidict
from tqdm import tqdm
import subprocess
import random
import shutil
import re
import warnings
import abc
import dataclasses
import typing
import operator
import tempfile
import threading
import queue
import functools

DEBUG = True


APKTOOL_PATH = os.path.join('/', 'usr', 'local', 'bin', 'apktool')
ZIPALIGN_PATH = os.path.join('/', 'bin', 'zipalign')
UBER_APK_SIGNER_PATH = os.path.join(
    '/', 'usr', 'local', 'bin', 'uber-apk-signer.jar')

MODELS_PATH = os.path.join('.', 'models')
METADATAS_PATH = os.path.join('.', 'metadatas')
BENIGN_APKS = os.path.join('.', 'benign_apks')
MALWARE_APKS = os.path.join('.', 'malware_apks')

BEFORE_APKS_PATH = os.path.join('.', 'data', 'Before-Apps')
AFTER_APKS_PATH = os.path.join('.', 'data', 'After-Apps')
BEFORE_OPSEQS_PATH = os.path.join('.', 'data', 'Before-Opseqs')
AFTER_OPSEQS_PATH = os.path.join('.', 'data', 'After-Opseqs')

BENIGN_LABEL = 'Benign'
MALWARE_LABEL = 'Malware'

# opseq file name format: <app_name>.apk.opseq
OPSEQS_FILENAME_FORMAT = re.compile(r'^(.+)\.apk\.opseq$')
# malware file name format: app<app_number>.apk
MALWARE_FILENAME_FORMAT = re.compile(r'^app(\d+)\.apk$')
# benign file name format: <app_name>.apk
BENIGN_FILENAME_FORMAT = re.compile(r'^(.+)\.apk$')

READ_TEST_METADATA_SCRIPT = os.path.join('.', 'readMetadata.lua')
RUN_MODEL_SCRIPT = os.path.join('.', 'runModel.lua')

LOCALS_PATTERN = re.compile(r"\s+\.locals\s(?P<local_amount>\d+)")


DALVIK_OPCODES = bidict()
with open('DalvikOpcodes.txt', 'r') as f:
    for line in f:
        line = line.strip()
        op, val = line.split('\t')
        DALVIK_OPCODES[op] = val


@dataclasses.dataclass
class App:
    name: str
    label: str
    path: typing.Optional[str] = None # directory path of the app

    @property
    def is_malware(self) -> bool:
        return self.label == MALWARE_LABEL

    @property
    def is_benign(self) -> bool:
        return self.label == BENIGN_LABEL
    
    @property
    def opseq_name(self) -> str:
        return f'{self.name}.apk.opseq'
    
    @property
    def apk_name(self) -> str:
        return f'{self.name}.apk'
    
    @property
    def opseq_path(self) -> str:
        return os.path.join(self.path, self.opseq_name)
    
    @property
    def apk_path(self) -> str:
        return os.path.join(self.path, self.apk_name)
    

    def __str__(self) -> str:
        return f'{self.name} ({self.label})'

    def __repr__(self) -> str:
        return f'{self.name} ({self.label})'

def get_test_metadata(metadata_path: str) -> list[App]:
    if DEBUG:
        print(f'[+] Getting test metadata from {metadata_path}')
    metadata = subprocess.run(['th', READ_TEST_METADATA_SCRIPT,
                              '-metadataPath', metadata_path], capture_output=True, text=True)
    lines = metadata.stdout.splitlines()
    # format of first line: 1=<label_name_1>\t2=<label_name_2>\t...
    label_names = {k: v for k, v in [label.split(
        '=') for label in lines[0].strip().split('\t')]}
    # format of remaining lines: <app_name>.apk.opseqs\t<app_label>
    # data = {}
    data = []
    # return {OPSEQS_FILENAME_FORMAT.match(app_name).group(1): label_names[app_label] for app_name, app_label in [line.split('\t') for line in lines[1:]]}
    for line in tqdm(lines[1:], desc='Parsing the metadata', disable=not DEBUG, leave=None):
        app_name, app_label = line.strip().split('\t')
        # data[OPSEQS_FILENAME_FORMAT.match(
        #     app_name).group(1)] = label_names[app_label]
        data.append(App(OPSEQS_FILENAME_FORMAT.match(
            app_name).group(1), label_names[app_label]))
    return data

def copy_apks(apks: list[App], malware_source_path: str, benign_source_path: str, dest_path: str) -> list[App]:
    transfered_files = []
    # remove all files in dest_path
    for file in os.listdir(dest_path):
        os.remove(os.path.join(dest_path, file))
    for app in tqdm(apks, desc='Copying apks', disable=not DEBUG, leave=None):
        # print(app_name)
        dest = os.path.join(dest_path, app.apk_name)

        if app.is_malware:
            source = malware_source_path
        elif app.is_benign:
            source = benign_source_path
        else:
            raise ValueError(f'Invalid app label: {app.label}')
        sour = os.path.join(source, app.apk_name)
        if not os.path.exists(sour):
            warnings.warn(f'File {sour} does not exist')
            continue

        shutil.copy(sour, dest)
        transfered_files.append(App(app.name, app.label, dest_path))
    return transfered_files


class SavableInterface(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook__(cls, subclass):
        return ((hasattr(subclass, 'save') and callable(subclass.save)) or NotImplemented)

    @abc.abstractmethod
    def save(self, path: str) -> None:
        """Save the object to the given path"""
        raise NotImplementedError


@dataclasses.dataclass
class Line:
    value: str
    opcode: typing.Optional[str] = None

    @property
    def has_opcode(self) -> bool:
        return self.opcode is not None

    @property
    def indentation(self) -> int:
        return len(self.value) - len(self.value.lstrip())


class Method:
    def __init__(self, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.opcode_map = opcode_map
        self.lines: list[Line] = []
        self.has_opcode = False

    def add_line(self, line: str, position: int = None) -> None:
        if position is None:
            position = len(self.lines)
        line = line.rstrip()
        if not line:
            return
        sline = line.lstrip()
        opcode = None
        if sline and not sline.startswith('.') and not sline.startswith('#'):
            parts = sline.split(" ", maxsplit=1)
            if (len(parts) >= 1) and (parts[0] in self.opcode_map):
                opcode = self.opcode_map[parts[0]]
                self.has_opcode = True
        self.lines.insert(position, Line(line, opcode))

    def remove_line(self, position: int) -> None:
        self.lines.pop(position)

    def get_lines(self) -> typing.Generator[tuple[int, Line], None, None]:
        return (l for l in enumerate(self.lines) if l[1].has_opcode)

    def get_opcode_seq(self) -> str:
        return "".join(map(operator.attrgetter('opcode'), (l[1] for l in self.get_lines())))

    def __str__(self) -> str:
        return '\n'.join(map(operator.attrgetter('value'), self.lines))


class SmaliFile(SavableInterface):
    def __init__(self, smali_path: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.smali_path = smali_path
        self.opcode_map = opcode_map
        self.lines: list[typing.Union[Method, str]] = []
        self.current_method: typing.Optional[Method] = None
        self.has_opcode = False

    @classmethod
    def from_file(cls, smali_path: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        smali = cls(smali_path, opcode_map)
        with open(smali_path, mode="r", encoding="utf-8") as smali_file:
            t = tqdm(total=os.path.getsize(smali_path), unit="B", postfix={
                     "dir": smali_path}, disable=not DEBUG, leave=None)
            for line in smali_file:
                t.update(len(line))
                smali.add_line(line)
            if smali.current_method:
                raise SyntaxError(
                    f"File {smali.smali_path} contains an closed method")
            t.close()
        return smali

    def add_line(self, line: str) -> None:
        sline = line.strip()
        if not sline:
            return
        if sline.startswith(".method"):
            if self.current_method:
                raise SyntaxError(
                    f"File {self.smali_path} contains an closed method")
            self.current_method = Method(self.opcode_map)
            self.current_method.add_line(line)
        elif sline.startswith(".end method"):
            if not self.current_method:
                raise SyntaxError(
                    f"File {self.smali_path} contains a hanging .end method")
            self.current_method.add_line(line)
            self.lines.append(self.current_method)
            # If any of the methods have an opcode then the file has an opcode
            self.has_opcode |= self.current_method.has_opcode
            self.current_method = None
        elif self.current_method:  # inside the method
            self.current_method.add_line(line)
        else:  # self.current_method is None
            self.lines.append(line.rstrip())

    def get_methods(self) -> typing.Generator[tuple[int, Method], None, None]:
        return (l for l in enumerate(self.lines) if isinstance(l[1], Method) and l[1].has_opcode)

    def get_opcode_seq(self) -> str:
        if self.current_method:
            raise SyntaxError(
                f"File {self.smali_path} contains an closed method")
        return "\n".join(map(operator.methodcaller('get_opcode_seq'), (m[1] for m in self.get_methods()))) if self.has_opcode else ""

    def __str__(self) -> str:
        return '\n'.join(str(l) for l in self.lines)

    def save(self, path: str) -> None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, mode="w", encoding="utf-8", newline='\n') as smali_file:
            smali_file.write(str(self))


class SmaliDir(SavableInterface):
    def __init__(self, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        self.decoded_dir = decoded_dir
        self.opcode_map = opcode_map
        self.smali_files: list[SmaliFile] = []

    @classmethod
    def from_dir(cls, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES):
        smali = cls(decoded_dir, opcode_map)
        smali_dir = os.path.join(smali.decoded_dir, "smali")
        total = 1
        if DEBUG:
            total = sum(len(files) for _, _, files in os.walk(smali_dir))
        t = tqdm(total=total, unit="files", disable=not DEBUG, leave=None)
        for root, dirs, files in os.walk(smali_dir):
            dirs.sort()
            t.set_postfix(dir=root[len(smali.decoded_dir):])
            t.update(0)
            for file in sorted(f for f in files if f.endswith(".smali")):
                smali_file = os.path.join(root, file)
                smali.add_file(smali_file)
                t.update()
        t.close()
        return smali

    def add_file(self, file_path: str) -> None:
        self.smali_files.append(
            SmaliFile.from_file(file_path, self.opcode_map))

    def get_files(self) -> typing.Generator[SmaliFile, None, None]:
        return (f for f in self.smali_files if f.has_opcode)

    def get_opcode_seq(self) -> str:
        # return "\n".join(f.get_opcode_seq() for f in self.smali_files if f.has_opcode)
        return "\n".join(map(operator.methodcaller('get_opcode_seq'), self.get_files()))

    # def apply_obfuscation(self) -> None:
    #     # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
    #     files_list = list(self.get_files())
    #     for smali_file in tqdm(files_list, unit="files", disable=not DEBUG, leave=None):
    #         methods_list = list(smali_file.get_methods())
    #         for i, method in tqdm(methods_list, unit="methods", disable=not DEBUG, leave=None):
    #             lines_list = list(method.get_lines())
    #             for j, line in tqdm(lines_list, unit="lines", disable=not DEBUG, leave=None):
    #                 pass
    
    # def apply_attack(self) -> None:
    #     for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
    #         for i, method in tqdm(smali_file.lines, unit="methods", disable=not DEBUG, leave=None):
    #             if isinstance(method, Method):
    #                 method.apply_attack()
    
    def apply_nop(self) -> None:
       # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        files_list = list(self.get_files())
        for smali_file in tqdm(files_list, unit="files", disable=not DEBUG, leave=None):
            methods_list = list(smali_file.get_methods())
            for i, method in tqdm(methods_list, unit="methods", disable=not DEBUG, leave=None):
                lines_list = list(method.get_lines())
                amount =  len(method.lines)
                offset = 0
                for j, line in tqdm(lines_list, unit="lines", disable=not DEBUG, leave=None):
                    method.add_line((' ' * line.indentation) + "nop", position=(j + offset + 1))
                    offset += len(method.lines) - amount
                    amount = len(method.lines)

    def apply_goto(self) -> None:
       # Im unreaveling the generators into lists because im adding lines to the elements to the underlying list which causes an infinite generator
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            m = Method(self.opcode_map)
            for method in tqdm(smali_file.lines, unit="methods", disable=not DEBUG, leave=None):
                if isinstance(method, Method) and (" abstract " not in method.lines[0].value) and (" native " not in method.lines[0].value):
                    m.add_line(method.lines[0].value)
                    for line in tqdm(method.lines[1:-1], unit="lines", disable=not DEBUG, leave=None):
                        if LOCALS_PATTERN.match(line.value):
                            m.add_line(line.value)
                            m.add_line(f"{' ' * line.indentation}goto/32 :after_last_instruction")
                            m.add_line(f"{' ' * line.indentation}:before_first_instruction")
                        else:
                            m.add_line(line.value)
                    m.add_line(f"{' ' * method.lines[-1].indentation}:after_last_instruction")
                    m.add_line(f"{' ' * method.lines[-1].indentation}goto/32 :before_first_instruction")
                    m.add_line(method.lines[-1].value)
                    method.lines = m.lines
            
    def save(self, directory: str):
        for smali_file in tqdm(self.smali_files, unit="files", disable=not DEBUG, leave=None):
            smali_dir = os.path.join(
                directory, smali_file.smali_path[len(self.decoded_dir + os.sep):])
            smali_file.save(smali_dir)


def parse_apk(app: App, decoded_dir: str, opcode_map: dict[str, str] = DALVIK_OPCODES, show_steps: bool = False) -> SmaliDir:
    if show_steps:
        subprocess.run([APKTOOL_PATH, "d", "-f", app.apk_path, "-o",
                        decoded_dir, "--frame-path", decoded_dir], check=True, input=b"\r\n")
    else:
        subprocess.run([APKTOOL_PATH, "d", "-f", app.apk_path, "-o",
                        decoded_dir, "--frame-path", decoded_dir], check=True, input=b"\r\n", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return SmaliDir.from_dir(decoded_dir, opcode_map)

def write_opseq(smali: SmaliDir, opseq_path: str) -> None:
    with open(opseq_path, mode="w", encoding="utf-8", newline='\n') as opseq_file:
        opseq_file.write(smali.get_opcode_seq())

def write_smali_dir(smali_dir: SmaliDir, decoded_dir: str) -> None:
    smali_dir.save(decoded_dir)

def build_apk(decoded_dir: str, output_apk_path: str, show_steps: bool = False) -> None:
    if show_steps:
            subprocess.run([APKTOOL_PATH, "b", "-f", decoded_dir, "-o",
                            output_apk_path, "--frame-path", decoded_dir], check=True, input=b"\r\n")
    else:
        subprocess.run([APKTOOL_PATH, "b", "-f", decoded_dir, "-o",
                        output_apk_path, "--frame-path", decoded_dir], check=True, input=b"\r\n", stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    
def sign_apks(apks_path: str, output_path: str, show_steps: bool = False) -> None:
    # https://github.com/patrickfav/uber-apk-signer
    if show_steps:
        subprocess.run(["java", "-jar", UBER_APK_SIGNER_PATH, 
                        "-a", apks_path,
                        '-o', output_path,
                        '--zipAlignPath', ZIPALIGN_PATH], check=True)   
    else:
        subprocess.run(["java", "-jar", UBER_APK_SIGNER_PATH, 
                        "-a", apks_path,
                        '-o', output_path,
                        '--zipAlignPath', ZIPALIGN_PATH], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def run_model(model_path: str, data_dir: str, use_cuda: bool = False) -> list[App]:
    if use_cuda:
        predictions = subprocess.run(['th', RUN_MODEL_SCRIPT,
                                    '-dataDir', data_dir,
                                    '-modelPath', model_path,
                                    '-useCUDA'],
                                    capture_output=True, text=True)
    else:
        predictions = subprocess.run(['th', RUN_MODEL_SCRIPT,
                                    '-dataDir', data_dir,
                                    '-modelPath', model_path],
                                    capture_output=True, text=True)
    lines = predictions.stdout.splitlines()
    label_names = {k: v for k, v in [label.split(
        '=') for label in lines[0].strip().split('\t')]}
    data = []
    for line in tqdm(lines[1:], desc='Parsing the predictions', disable=not DEBUG, leave=None):
        app_name, app_label = line.strip().split('\t')
        # data[OPSEQS_FILENAME_FORMAT.match(
        #     app_name).group(1)] = label_names[app_label]
        data.append(App(OPSEQS_FILENAME_FORMAT.match(
            app_name).group(1), label_names[app_label], data_dir))
    return data

def display_confusion_matrix(prediction: list[App], ground_truth: list[App]) -> None:
    ground_truth = {app.name: (app.label == MALWARE_LABEL) for app in ground_truth}
    prediction = {app.name: (app.label == MALWARE_LABEL) for app in prediction}
    if len(prediction) != len(ground_truth):
        raise ValueError(
            f'The number of unique predictions ({len(prediction)}) and the number of unique ground truths ({len(ground_truth)}) are different')
    confusion_matrix = [[0, 0], [0, 0]]
    for app in prediction:
        if app in ground_truth:
            confusion_matrix[ground_truth[app]][prediction[app]] += 1
        else:
            raise ValueError(
                f'The app {app} is not in the ground truth')
    # print(f'Confusion matrix: {confusion_matrix}')
    # pretty print
    print('Confusion matrix:')
    print(' ' * 4, 'PREDICTED')
    print(' ' * 4, '0', '1')
    print(' ' * 4, '-' * 3)
    print(' ' * 4, confusion_matrix[0][0], confusion_matrix[0][1])
    print(' ' * 4, confusion_matrix[1][0], confusion_matrix[1][1])
    print(' ' * 4, '-' * 3)
    print(' ' * 4, '0', '1')
    print(' ' * 4, 'GROUND TRUTH')
    print(' ' * 4, '-' * 3)
    print(' ' * 4, 'BENIGN', 'MALWARE')
    print(' ' * 4, '-' * 3)
    print('True Positive (Malware detected):', confusion_matrix[1][1])
    print('False Negative (Malware not detected):', confusion_matrix[1][0])
    # print('True Negative (Benign detected):', confusion_matrix[0][0])
    # print('False Positive (Benign not detected):', confusion_matrix[0][1])
    print('Recall (Malware detected):', confusion_matrix[1][1] / (confusion_matrix[1][1] + confusion_matrix[1][0]))
    



NUM_THREADS = 5
q = queue.Queue()
prog = tqdm(total=1, disable=not DEBUG, leave=None)

def copy_apk(app: App, malware_source_path: str, benign_source_path: str, dest_path: str) -> typing.Optional[App]:
    # remove all files in dest_path
    dest = os.path.join(dest_path, app.apk_name)
    if os.path.exists(dest):
        os.remove(dest)  
    if app.is_malware:
        source = malware_source_path
    elif app.is_benign:
        source = benign_source_path
    else:
        raise ValueError(f'Invalid app label: {app.label}')
    sour = os.path.join(source, app.apk_name)
    if not os.path.exists(sour):
        if DEBUG:
            warnings.warn(f'File {sour} does not exist')
        return None

    shutil.copy(sour, dest)
    return App(app.name, app.label, dest_path)


def process_app():
    global q
    global prog
    while True:
        app = q.get()
        apk = copy_apk(app, MALWARE_APKS, BENIGN_APKS, BEFORE_APKS_PATH)
        if apk:
            with tempfile.TemporaryDirectory() as decoded_dir:
                smali_dir = parse_apk(apk, decoded_dir)
                write_opseq(smali_dir, os.path.join(BEFORE_OPSEQS_PATH, app.opseq_name))
                # attack here
                # smali_dir.apply_nop()
                smali_dir.apply_goto()
                # attack(smali_dir)
                write_smali_dir(smali_dir, decoded_dir)
                build_apk(decoded_dir, os.path.join(AFTER_APKS_PATH, app.apk_name))
                write_opseq(smali_dir, os.path.join(AFTER_OPSEQS_PATH, app.opseq_name))
        prog.update()
        q.task_done()

run = '1'
metadata = get_test_metadata(os.path.join(
    METADATAS_PATH, f'metadata{run}.th7'))
metadata = [m for m in metadata if m.label == MALWARE_LABEL][:5]

prog.total = len(metadata)
prog.desc = 'Processing apps'
# prog.disable = not DEBUG
prog.refresh()
threads = []
for meta in metadata:
    q.put(meta)

for i in range(NUM_THREADS):
    t = threading.Thread(target=process_app)
    t.daemon = True
    t.start()
    threads.append(t)
q.join()
before_predictions = run_model(os.path.join(MODELS_PATH, f'model{run}.th7'), BEFORE_OPSEQS_PATH)
display_confusion_matrix(before_predictions, metadata)
after_predictions = run_model(os.path.join(MODELS_PATH, f'model{run}.th7'), AFTER_OPSEQS_PATH)
display_confusion_matrix(after_predictions, metadata)
# sign_apks(BEFORE_APKS_PATH, AFTER_APKS_PATH)



# transfered = copy_apks(metadata, MALWARE_APKS, BENIGN_APKS, BEFORE_APKS_PATH)

# for app in tqdm(transfered, desc='Decoding APKs', disable=not DEBUG, leave=None):
#     with tempfile.TemporaryDirectory() as decoded_dir:
#         smali_dir = parse_apk(app, decoded_dir)
#         write_opseq(smali_dir, os.path.join(
#             BEFORE_OPSEQS_PATH, app.opseq_name))
#         write_smali_dir(smali_dir, decoded_dir)
#         build_apk(decoded_dir, os.path.join(
#             BEFORE_APKS_PATH, app.apk_name))
# sign_apks(BEFORE_APKS_PATH, AFTER_APKS_PATH)

# apps = {}

# for i in range(1, 6):
#     metadata = get_test_metadata(os.path.join(METADATAS_PATH, f'metadata{i}.th7'))
#     for app in tqdm(metadata, desc=f'Parsing metadata {i}', disable=not DEBUG, leave=None):
#         if app.label == MALWARE_LABEL:
#             apps[app.name] = app

# print(f'Number of apps: {len(apps)}')

# total = 0
# for app in tqdm(apps, 'Copying files', disable=not DEBUG, leave=None):
#     path = os.path.join(MALWARE_APKS, f'{app}.apk')
#     if os.path.exists(path):
#         shutil.copy(path, os.path.join(BEFORE_APKS_PATH, f'{app}.apk'))
#         # total += os.path.getsize(os.path.join(MALWARE_APKS, f'{app}.apk'))
#     else:
#         warnings.warn(f'App {app} not found')
# print(f'Total size: {total}')

# run = '1'
# metadata = get_test_metadata(os.path.join(
#     METADATAS_PATH, f'metadata{run}.th7'))
# metadata = [m for m in metadata if m.label == MALWARE_LABEL]
# print(f'size of metadata: {len(metadata)}')
# transfered = copy_apks(metadata, MALWARE_APKS, BENIGN_APKS, BEFORE_APKS_PATH)
# print(len(transfered))
# for apk_path in tqdm(transfered, unit="apks", disable=not DEBUG, leave=None):
#     with tempfile.TemporaryDirectory() as decoded_dir:
#         smali_dir = parse_apk(apk_path, decoded_dir, DALVIK_OPCODES)
#         write_opseq(smali_dir, os.path.join(BEFORE_OPSEQS_PATH,
        

# def sample_apps(apps: dict[str, str], sample_size: int) -> dict[str, str]:
#     return dict(random.sample(apps.items(), sample_size))
