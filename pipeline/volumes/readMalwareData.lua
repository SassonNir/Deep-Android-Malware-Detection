
-- read the malware data
--	 in setup mode 
--	- read all the files
--  - decide if it should be in dataset
--  - save a list of all files
--  - 			

-- read the whole program into a tensor
function readfileFunc_tensor(filename)

	local contents = {}

	local f = torch.DiskFile(filename)
	f.quiet(f)
	local c = 'a'
	local count = 0
	local func = {}

	for i = 1,opt.kernelLength do
		table.insert(func,1)
		count = count + 1
	end

	local nFuncs = 0
	-- while c ~= '' do --and count <= opt.programLen do -- potential bug...
	while c ~= '' and count <= opt.programLen do -- potential bug...
		c = f.readString(f,'*l')
		local len = #c
		if len > 0 then

			for k = 1,len,2 do
				local num = string.sub(c,k,k+1)
				local n = tonumber(num,16)
				table.insert(func,n + 2) -- plus 2 so that our lowest symbol is '2' i.e. no_op is '2'
				count = count + 1
			end
			nFuncs = nFuncs + 1

			for i = 1,opt.kernelLength do
				table.insert(func,1)
				count = count + 1
			end

			if opt.markFunctionEnds then
				table.insert(func,255) -- mark the end of each function
			end
		end
	end
	return torch.ByteTensor(func),nFuncs,count
end

-- get an upper bound on the number of malware files
-- we will discard some files that are too short etc
function upperBoundNumberOfFiles(rootDir)
	local numberOfFilesBound = 0
	for f in paths.files(rootDir) do
		if f ~= '.' and f ~= '..' then
			numberOfFilesBound = numberOfFilesBound + 1
		end
	end
	-- local malwareDirs = paths.dir(rootDir)	
	-- for i = 1,#malwareDirs do
	-- 	local dir = malwareDirs[i]
	-- 	if dir ~= '.' and dir ~= '..' and paths.dirp(paths.concat(rootDir,dir)) then
	-- 		local malwarefiles = paths.dir(paths.concat(rootDir,dir))	
	-- 		-- number of files minus '.' and '..'
	-- 		numberOfFilesBound = numberOfFilesBound + #malwarefiles - 2
	-- 	end
	-- end
	-- print('upper bound number of programs ',numberOfFilesBound)
	return numberOfFilesBound
end


-- reads the malware data into a tensor
-- We read all the opcodes into a single block of memory
-- this is because each program can be a different length
-- so storing in a 2D array will waste lots space
-- We also can't use a Lua list as they are limited to 2GB
--
-- allData.program          - tensor (i.e. 1D array of bytes) containing all opcodes
-- allData.programStartPtrs - pointers to start of each program in allData.program
-- allData.programLengths   - the length of each opcode sequence
--
-- For example, to access program 3 do
--
-- local ptr = allData.programStartPrts[3]
-- local len = allData.programLengths[3]
-- local prog = allData.program[{{ptr,ptr + len - 1}}]
--
-- function readMalwareData(rootDir)

-- 	print('reading files with version 2')

-- 	local malwareDirs = paths.dir(rootDir)	
-- 	local upperBoundNumFiles = upperBoundNumberOfFiles(rootDir)

-- 	local meanProgramLen = 50000

-- 	local allData = {
-- 		program = torch.ones(upperBoundNumFiles * meanProgramLen):byte(),
-- 		programStartPtrs = {},
-- 		programLengths = {},
-- 	}

-- 	local programLen = {}

-- 	local progPtr = 1
-- 	local programCount = 0


-- 	-- for i = 1,#malwareDirs do
-- 	for f in paths.files(rootDir) do

-- 		-- local file = malwareDirs[i]
-- 		local file = f
-- 		local fullFile = paths.concat(rootDir, file)
-- 		-- check file exists and ends in .opseq
-- 		if string.sub(file,-6) == '.opseq' then
-- 			print('reading file ',fullFile)
			
-- 			local contents = readfileFunc_tensor(fullFile)


-- 			programCount = programCount + 1
-- 			if programCount % 100 == 0 then
-- 				print('programs read ',programCount,collectgarbage("count"))
-- 				collectgarbage()
-- 			end

-- 			local programLength = contents:size(1)

-- 			-- if needed - increase the size of the storage
-- 			if (progPtr + programLength - 1) > allData.program:size(1) then
-- 				local currSize = allData.program:size(1)
-- 				allData.program = allData.program:resize(currSize * 1.05)
-- 			end

-- 			table.insert(allData.programStartPtrs,progPtr)
-- 			table.insert(allData.programLengths,programLength)

-- 			print('program length ',programLength)
-- 			print('progPtr ',progPtr)
-- 			-- print('program ', allData.program[{{progPtr, progPtr+2}}])
-- 			print('program ', #allData.program)
-- 			print('content ', #contents)
-- 			-- print('content ', 
			

-- 			-- insert the program into the memory
-- 			allData.program[{{progPtr,progPtr + programLength - 1}}] = contents
-- 			progPtr = progPtr + programLength
-- 		end
-- 	end

-- 	allData.program = allData.program:resize(progPtr) -- discard redundant rows
-- 	allData.programStartPtrs = torch.Tensor(allData.programStartPtrs)
-- 	allData.programLengths = torch.Tensor(allData.programLengths)

-- 	return allData,programLen
-- end


function readMalwareData(rootDir, metaData)

	-- print('reading files with version 2')

	local upperBoundNumFiles = upperBoundNumberOfFiles(rootDir)

	local meanProgramLen = 50000

	local allData = {
		program = torch.ones(upperBoundNumFiles * meanProgramLen):byte(),
		programStartPtrs = {},
		programLengths = {},
		programNames = {},
	}

	local programLen = {}

	local progPtr = 1
	local programCount = 0

	-- for i = 1,#metaData.filesList do
	for f in paths.files(rootDir) do

		local file = f
		local fullFile = paths.concat(rootDir,file)

		if string.sub(file,-6) == '.opseq' then
			-- print('reading file ',fullFile)

			local contents = readfileFunc_tensor(fullFile)
			-- print('contents size ',contents:size(1))

			programCount = programCount + 1
			-- if programCount % 100 == 0 then
			-- 	print('programs read ',programCount,collectgarbage("count"))
			-- 	collectgarbage()
			-- end

			local programLength = contents:size(1)

			-- if needed - increase the size of the storage
			if (progPtr + programLength - 1) > allData.program:size(1) then
				local currSize = allData.program:size(1)
				allData.program = allData.program:resize(currSize * 1.05)
			end

			table.insert(allData.programStartPtrs,progPtr)
			table.insert(allData.programLengths,programLength)
			table.insert(allData.programNames,file)

			-- insert the program into the memory
			allData.program[{{progPtr,progPtr + programLength - 1}}] = contents
			progPtr = progPtr + programLength
		end
	end


	allData.program = allData.program:resize(progPtr) -- discard redundant rows
	allData.programStartPtrs = torch.Tensor(allData.programStartPtrs)
	allData.programLengths = torch.Tensor(allData.programLengths)

	return allData,programLen
end